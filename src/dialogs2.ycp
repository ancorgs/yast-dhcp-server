/**
 * File:	include/dhcp-server/dialogs.ycp
 * Package:	Configuration of dhcp-server
 * Summary:	Dialogs definitions
 * Authors:	Vladim√≠r Bobek <vbobek@suse.cz>
 *
 * $Id$
 */

{

textdomain "dhcp-server";

import "Confirm";
import "Label";
import "Wizard";
import "DhcpServer";
import "Popup";
import "Address";
import "IP";
import "Hostname";
import "Progress";
import "DialogTree";
import "CWMServiceStart";
//import "ProductFeatures";
import "NetworkDevices";
import "Report";
import "Mode";
import "Netmask";

include "dhcp-server/helps.ycp";
include "dhcp-server/widgets.ycp";
include "dhcp-server/dns-server-management.ycp";
include "dhcp-server/dns-server-wizard.ycp";

/* Using expert UI */
//define boolean expert_ui = (ProductFeatures::GetFeature ("globals", "ui_mode") == "expert");

/* Start of common configuration section */

define list <term> time_combo_items = [
    // combo box item
    `item(`id("days"), _("Days")),
    // combo box item
    `item(`id("hours"), _("Hours")),
    // combo box item
    `item(`id("minutes"), _("Minutes")),
    // combo box item
    `item(`id("seconds"), _("Seconds"))
];

define integer TimeComboLabelLength () {
    integer max_length = 0;
    foreach (term combo_item, time_combo_items, {
	string combo_label = (string) combo_item[1]:" ";
	integer current_length = size(combo_label);
	if (current_length > max_length) max_length = current_length;
    });
    
    return max_length;
}

define integer time2seconds (integer count, string unit) {
    if (unit == "days")
    {
	return count * 60 * 60 * 24;
    }
    else if (unit == "hours")
    {
	return count * 60 * 60;
    }
    else if (unit == "minutes")
    {
	return count * 60;
    }
    return count;
}

define map<string,any> seconds2time (integer seconds) {
    string unit = "seconds";
    integer count = seconds;
    if (seconds % (60 * 60 * 24) == 0)
    {
	return $[
	    "unit" : "days",
	    "count" : seconds / (60 * 60 * 24),
	];
    }
    if (seconds % (60 * 60) == 0)
    {
	return $[
	    "unit" : "hours",
	    "count" : seconds / (60 * 60),
	];
    }
    if (seconds % (60) == 0)
    {
	return $[
	    "unit" : "minutes",
	    "count" : seconds / (60),
	];
    }
    return $[
	"unit" : "seconds",
	"count" : seconds,
    ];

}

boolean quit = false;

/* Currently selected item in the interface table */
string current_item_iface = nil;

/**
 * Common Config Dialog - Card Selection
 * @return term for Get_CommonDialog()
 */
term Common_CardSelectionDialog() {
    term dialog = `VBox(
            `VBox(
		// Table - listing available network cards
		`Left( `Label( _("Network Cards for DHCP Server") ) ),
                `Table (
		    `id("nic_selection"),
		    `opt(`notify, `immediate),
		    `header (
			// TRANSLATORS: table header item
			_("Selected"),
			// TRANSLATORS: table header item
			_("Interface Name"),
			// TRANSLATORS: table header item
			_("Device Name"),
			// TRANSLATORS: table header item
			_("IP")
		    ),
		    []
		)
            ),
	    `HBox (
		// TRANSLATORS: a push-button
		`PushButton(`id("add"),    _("&Select")),
		// TRANSLATORS: a push-button
		`PushButton(`id("remove"), _("&Deselect"))
	    ),
	    `VStretch()
        );

    return dialog;
}

void SetInterfacesTableButtons () {
    string current_item = (string) UI::QueryWidget(`id("nic_selection"), `CurrentItem);

    // The currently selected item is active, can be deactivated
    if ((boolean) DhcpServerUI::ifaces[current_item, "active"]:nil == true) {
	UI::ChangeWidget(`id("add"),    `Enabled, false);
	UI::ChangeWidget(`id("remove"), `Enabled, true);
    // and vice versa
    } else {
	UI::ChangeWidget(`id("add"),    `Enabled, true);
	UI::ChangeWidget(`id("remove"), `Enabled, false);
    }
}

void RedrawInterfacesTable () {
    list <term> table_items = [];
    foreach (string iface, map <string, any> settings, DhcpServerUI::ifaces, {
	table_items = add(table_items, `item(
	    `id(iface),
	    (settings["active"]:false ? "x":""),
	    iface,
	    settings["device"]:"",
	    settings["ipaddr"]:""
	));
    });

    UI::ChangeWidget(`id("nic_selection"), `Items, table_items);
    if (current_item_iface != nil) {
	UI::ChangeWidget(`id("nic_selection"), `CurrentItem, current_item_iface);
    }
    
    SetInterfacesTableButtons();
}

void CardSelectionInit (string key)
{
    Wizard::DisableBackButton();

    foreach (string iface, NetworkDevices::List(""), {
	if (iface != "" && !issubstring(iface, "lo") && !issubstring(iface, "sit")) {
	    string device_name = NetworkDevices::GetValue(iface, "NAME");
	    if (size(device_name) > 40) {
		device_name = substring (device_name, 0, 37) + "...";
	    }
	    
	    DhcpServerUI::ifaces[iface] = $[
		"device" : device_name,
		"ipaddr" : (NetworkDevices::GetValue(iface, "BOOTPROTO") == "dhcp" ?
		    // TRANSLATORS: Table items; Informs that the IP is a DHCP Address
		    _("DHCP address")
		    :
		    NetworkDevices::GetValue(iface, "IPADDR")
		),
		"active" : false,
	    ];
	}
    });

    list <string> dhcp_ifaces = DhcpServer::GetAllowedInterfaces ();
    
    foreach (string iface, map <string, any> settings, DhcpServerUI::ifaces, {
        if (contains(dhcp_ifaces, iface)) DhcpServerUI::ifaces[iface,"active"] = true;
    });

    RedrawInterfacesTable();
}

symbol CardSelectionHandle (string key, map event) {
    string item_id = (string) UI::QueryWidget(`id("nic_selection"), `CurrentItem);

    SetInterfacesTableButtons();

    current_item_iface = item_id;

    if (event["ID"]:nil == "add") {
        DhcpServerUI::ifaces[item_id,"active"] = true;
    } else if (event["ID"]:nil == "remove") {
        DhcpServerUI::ifaces[item_id,"active"] = false;
    }

    RedrawInterfacesTable();

    return nil;
}

void CardSelectionStore (string key, map event)
{
    // FIXME: subnet handling
    list <string> allowed_interfaces = [];
    foreach (string iface, map <string, any> settings, DhcpServerUI::ifaces, {
	if (DhcpServerUI::ifaces[iface,"active"]:false == true) {
	    allowed_interfaces = add (allowed_interfaces, iface);
	}
    });
    
    DhcpServer::SetAllowedInterfaces (allowed_interfaces);
    DhcpServer::SetModified ();
}

boolean CardSelectionValidate (string key, map event) {
    if (event["ID"]:nil == `abort) {
	return true;
    }

    list <string> allowed_interfaces = [];
    list <string> configured_interfaces = [];
    foreach (string iface, map <string, any> settings, DhcpServerUI::ifaces, {
	if (DhcpServerUI::ifaces[iface,"active"]:false == true) {
	    allowed_interfaces = add (allowed_interfaces, iface);
	    if ( DhcpServer::GetInterfaceInformation(iface) != $[] ) {
		configured_interfaces = add(configured_interfaces, iface);
	    }
	    break;
	}
    });
    if (size(allowed_interfaces) <= 0) {
	// TRANSLATORS: popup error, DHCP Server needs to run on one or more interfaces,
	//              currently no one is selected
	Report::Error(_("At least one network interface must be selected."));
	return false;
    }

    if (size(configured_interfaces) <= 0) {
	// TRANSLATORS: popup error, DHCP Server requires selected interface to have 
	//              at least minimal configuration 
	return Popup::ContinueCancel(_("Selected network interface has currently no configuration (no assigned IP address 
and netmask). Using it in DHCP server configuration may not work.
Really use this interface?"));
    }
    return true;
}

/**
 * Common Config Dialog - Global Settings
 * @return term for Get_CommonDialog()
 */
term Common_GlobalSettingsDialog() {
    term ldap = `VBox(
	// configuration will be saved in ldap?
	`HBox (
    	    `Left(`CheckBox(`id("ldap"), `opt( `notify), _("&LDAP Support"), true)),
	    `HSpacing(2),
	    // FATE #227, comments #5 and #17
	    `Left (`HSquash (`TextEntry (`id ("ldap-dhcp-server-cn"), _("DHCP Server &Name (optional)"))))
	),
        `VSpacing(2)
    );

    term dialog = `VBox(
	    ldap,
            `HBox(
                `VBox(
		    // Textentry with name of the domain
                    `Left(`TextEntry(`id("domainname"), _("&Domain Name"))),

		    // Textentry with IP address of primary name server
                    `Left(`TextEntry(`id("primarydnsip"), _("&Primary Name Server IP"))),

		    // Textentry with IP address of secondary name server
                    `Left(`TextEntry(`id("secondarydnsip"), _("&Secondary Name Server IP"))),

		    // Textentry with IP address of default router
                    `Left(`TextEntry(`id("defaultgw"), _("Default &Gateway (Router) ")))
                ),
		`HSpacing(2),
                `VBox(
		    // Textentry with IP address of time server
                    `Left(`TextEntry(`id("timeserver"), _("NTP &Time Server"))),

		    // Textentry with IP address of print server
                    `Left(`TextEntry(`id("printserver"), _("&Print Server"))),

		    // Textentry with IP address of WINS (Windows Internet Naming Service) server
                    `Left(`TextEntry(`id("winsserver"), _("&WINS Server"))),
                    `Left(
			`HBox(
			    // Textentry with default lease time of IP address from dhcp server
                    	    `HSquash(`TextEntry(`id("defaultleasetime"), _("Default &Lease Time"))),
                	    `HSpacing(0.1),
			    `MinWidth(
				TimeComboLabelLength(),
				// Units for defaultleasetime
				`HSquash(`ComboBox(`id("defaultleasetimeunits"), _("&Units"), time_combo_items))
			    )
			)
                    )
                )
            ),
            `VStretch()
        );


    return dialog;
}

void GlobalSettingsValidChars ()
{
    // ValidChars definition for GlobalSettingsDialog
    UI::ChangeWidget(`id( "domainname" ),	`ValidChars, Address::ValidChars4);
    UI::ChangeWidget(`id( "primarydnsip" ),	`ValidChars, IP::ValidChars4);
    UI::ChangeWidget(`id( "secondarydnsip" ),	`ValidChars, IP::ValidChars4);
    UI::ChangeWidget(`id( "defaultgw" ),	`ValidChars, Address::ValidChars4);
    UI::ChangeWidget(`id( "timeserver" ),	`ValidChars, Address::ValidChars4);
    UI::ChangeWidget(`id( "printserver" ),	`ValidChars, Address::ValidChars4);
    UI::ChangeWidget(`id( "winsserver" ),	`ValidChars, Address::ValidChars4);
    UI::ChangeWidget(`id( "defaultleasetime" ),	`ValidChars, "0123456789");
}

string CurrentDomainName () {
    string current_domain_name = "";

    foreach (map<string,string> opt, DhcpServer::GetEntryOptions ("",""), {
	if (opt["key"]:nil == "domain-name") {
	    current_domain_name = opt["value"]:"";
	    if (regexpmatch (current_domain_name, "^[ \t]*\".*\"[ \t]*$"))
		current_domain_name = regexpsub (current_domain_name, "^[ \t]*\"(.*)\"[ \t]*$", "\\1");
	    break;
	}
    });

    return current_domain_name;
}

void GlobalSettingsInit (string key)
{
    // get the global options
    list< map<string,string> > options = DhcpServer::GetEntryOptions ("","");
    
    if ( options == nil ) 
    {
	options = [];
    }

    // setup the corresponding values
    foreach ( map<string,string> opt, options, ``{
	if ( opt["key"]:nil == "domain-name" )
	{
	    string value = opt["value"]:"";
	    if (regexpmatch (value, "^[ \t]*\".*\"[ \t]*$"))
		value = regexpsub (value, "^[ \t]*\"(.*)\"[ \t]*$", "\\1");
	    UI::ChangeWidget ( `id ("domainname"), `Value, value );
	}
	else if ( opt["key"]:nil == "domain-name-servers" )
	{
	    list<string> vals = splitstring ( opt["value"]:"", " ," );
	    vals = filter (string v, vals, ``(v != ""));
	    UI::ChangeWidget ( `id ("primarydnsip"), `Value, vals[0]:"" );
	    UI::ChangeWidget ( `id ("secondarydnsip"), `Value, vals[1]:"" );
	}
	else if ( opt["key"]:nil == "routers" )
	{
	    list<string> vals = splitstring ( opt["value"]:"", ", " );
	    vals = filter (string v, vals, ``(v != ""));
	    UI::ChangeWidget ( `id ("defaultgw"), `Value, vals[0]:"" );
	}
	else if ( opt["key"]:nil == "ntp-servers" )
	{
	    list<string> vals = splitstring ( opt["value"]:"", " " );
	    UI::ChangeWidget ( `id ("timeserver"), `Value, vals[0]:"" );
	}
	else if ( opt["key"]:nil == "lpr-servers" )
	{
	    list<string> vals = splitstring ( opt["value"]:"", " " );
	    UI::ChangeWidget ( `id ("printserver"), `Value, vals[0]:"" );
	}
	else if ( opt["key"]:nil == "netbios-name-servers" )
	{
	    list<string> vals = splitstring ( opt["value"]:"", " " );
	    UI::ChangeWidget ( `id ("winsserver"), `Value, vals[0]:"" );
	}
    });

    // get the global directives
    list< map<string,string> > directives = DhcpServer::GetEntryDirectives ("","");
    
    if ( directives == nil ) 
    {
	directives = [];
    }

    integer default_lease_time = 14400;

    // setup the corresponding values
    foreach ( map<string,string> opt, directives, ``{
	if ( opt["key"]:nil == "default-lease-time" )
	{
	    default_lease_time = tointeger ( opt["value"]:"0" );
	}
    });
    map vu = seconds2time (default_lease_time);
    integer value = vu["count"]:0;
    string unit = vu["unit"]:"seconds";
    UI::ChangeWidget ( `id ("defaultleasetime"), `Value, tostring (value) );
    UI::ChangeWidget ( `id ("defaultleasetimeunits"), `Value, unit );
    
    boolean ldap_in_use = DhcpServer::GetUseLdap();
    UI::ChangeWidget (`id ("ldap"), `Value, ldap_in_use);
    UI::ChangeWidget (`id ("ldap-dhcp-server-cn"), `Value, DhcpServer::GetLdapDHCPServerCN());
    UI::ChangeWidget (`id ("ldap-dhcp-server-cn"), `Enabled, ldap_in_use);

    GlobalSettingsValidChars ();
}

symbol GlobalSettingsHandle (string key, map event)
{
    if (event ["ID"]:nil == "ldap" && event ["EventReason"]:nil == "ValueChanged")
    {
	boolean ldap = (boolean) UI::QueryWidget ( `id ("ldap"), `Value );

	// LDAP switch
	SetUseLdap (ldap);
	ldap = DhcpServer::GetUseLdap ();
	UI::ChangeWidget (`id ("ldap"), `Value, ldap);
	
	// ldap-dhcp-server-cn switch
	UI::ChangeWidget (`id ("ldap-dhcp-server-cn"), `Enabled, ldap);
    }
    return nil;
}

void GlobalSettingsStore (string key, map event)
{
    list< map<string,string> > directives = [];
    
    // get the global options
    list< map<string,string> > options = DhcpServer::GetEntryOptions ("","");
    
    if ( directives == nil ) 
    {
	directives = [];
    }

    // filter out those we know to change
    list<string> keys = [ "domain-name", "domain-name-servers", 
	"routers", "ntp-servers", "lpr-servers", "netbios-name-servers" ];
	
    options = filter ( map<string,string> opt, options, ``( 
	! contains (keys, opt["key"]:"")
    ));
    
    string value = (string) UI::QueryWidget ( `id ("domainname"), `Value );
    if (size(value)>0)
    {
	options = add (options, $[ "key" : "domain-name",
	    "value": sformat ("\"%1\"", value) ] );
    }

    string value1 = (string) UI::QueryWidget ( `id ("primarydnsip"), `Value );
    string value2 = (string) UI::QueryWidget ( `id ("secondarydnsip"), `Value );
    if (size(value1)>0 || size(value2)>0)
    {
	value1 = value1 == nil ? "" : value1;
	value2 = value2 == nil ? "" : value2;

	string domain_servers =
	    value1 + ((size(value2) > 0) ? (size(value1) > 0 ? ", " : "") + value2 : "");

	options = add (options, $[ "key" : "domain-name-servers", "value": domain_servers ] );
    }

    value = (string) UI::QueryWidget ( `id ("defaultgw"), `Value );
    if (size(value)>0)
    {
	options = add (options, $[ "key" : "routers", "value": value ] );
    }

    value = (string) UI::QueryWidget ( `id ("timeserver"), `Value );
    if (size(value)>0)
    {
	options = add (options, $[ "key" : "ntp-servers", "value": value ] );
    }

    value = (string) UI::QueryWidget ( `id ("printserver"), `Value );
    if (size(value)>0)
    {
	options = add (options, $[ "key" : "lpr-servers", "value": value ] );
    }

    value = (string) UI::QueryWidget ( `id ("winsserver"), `Value );
    if (size(value)>0)
    {
	options = add (options, $[ "key" : "netbios-name-servers", "value": value ] );
    }

    DhcpServer::SetEntryOptions ("","", options);

    // get the global directives
    directives = DhcpServer::GetEntryDirectives ("","");
    if ( directives == nil ) 
    {
	directives = [];
    }
    
    // filter out the known ones
    keys = [ "default-lease-time" ];
    
    directives = filter ( map<string,string> opt, directives, ``( 
	! contains (keys, opt["key"]:"")
    ));

    value = (string)UI::QueryWidget ( `id ("defaultleasetime"), `Value );
    if (size(value)>0)
    {
	integer val = tointeger (value);
	string units = (string)
	    UI::QueryWidget ( `id ("defaultleasetimeunits"), `Value );
	val = time2seconds (val, units);
	directives = add (directives, $[ "key" : "default-lease-time", "value": tostring (val) ] );
    }

    if (UI::WidgetExists (`id ("ldap-dhcp-server-cn"))) {
	string ldap_dhcp_server_cn = (string) UI::QueryWidget (`id ("ldap-dhcp-server-cn"), `Value);
	DhcpServer::SetLdapDHCPServerCN (ldap_dhcp_server_cn);

	// save ldap-dhcp-server-cn only when set
	if (ldap_dhcp_server_cn != "") {
	    // backslash quotes in the ldap-dhcp-server-cn entry, just to be safe
	    ldap_dhcp_server_cn = mergestring (splitstring (ldap_dhcp_server_cn, "\""), "\\\"");
	    directives = add (directives, $[ "key" : "ldap-dhcp-server-cn", "value": sformat ("\"%1\"", ldap_dhcp_server_cn) ] );
	}
    }

    DhcpServer::SetEntryDirectives ("","", directives);

    DhcpServer::SetModified ();
}

boolean GlobalSettingsValidate (string key, map event)
{
    string domainname =		(string) UI::QueryWidget ( `id ("domainname"),		`Value );
    string primarydnsip =	(string) UI::QueryWidget ( `id ("primarydnsip"),	`Value );
    string secondarydnsip =	(string) UI::QueryWidget ( `id ("secondarydnsip"),	`Value );
    string defaultgw =		(string) UI::QueryWidget ( `id ("defaultgw"),		`Value );
    string timeserver =		(string) UI::QueryWidget ( `id ("timeserver"),		`Value );
    string printserver =	(string) UI::QueryWidget ( `id ("printserver"),		`Value );
    string winsserver =		(string) UI::QueryWidget ( `id ("winsserver"),		`Value );
    string defaultleasetime =	(string) UI::QueryWidget ( `id ("defaultleasetime"),	`Value );

    // FIXME:	it is not defined which of values must be filled (must be lease time defined?)
    //		shouldn't be lease time controlled for too small or too big value?

    // checking domain name
    if ( domainname != "" && Hostname::CheckDomain(domainname) != true ) {
	UI::SetFocus ( `id ( "domainname" ) );
	Popup::Error ( Hostname::ValidDomain () );
	return false;
    }

    // checking primary server
    if ( primarydnsip != "" && IP::Check4(primarydnsip) != true ) {
	UI::SetFocus ( `id ( "primarydnsip" ) );
	Popup::Error ( IP::Valid4  () );
	return false;
    }

    // checking secondary server
    if ( secondarydnsip != "" && IP::Check4(secondarydnsip) != true ) {
	UI::SetFocus ( `id ( "primarydnsip" ) );
	Popup::Error ( IP::Valid4  () );
	return false;
    }    

    // checking default gateway server
    if ( defaultgw != "" &&
	Hostname::Check(defaultgw) != true && Hostname::CheckFQ(defaultgw) != true &&
	IP::Check4(defaultgw) != true
    ) {
	UI::SetFocus ( `id ( "defaultgw" ) );
	// error popup
	Popup::Error ( _("The specified value is not a valid hostname or IP address.") );
	return false;
    }

    // checking time server
    if ( timeserver != "" &&
	Hostname::Check(timeserver) != true && Hostname::CheckFQ(timeserver) != true &&
	IP::Check4(timeserver) != true
    ) {
	UI::SetFocus ( `id ( "timeserver" ) );
	// error popup
	Popup::Error ( _("The specified value is not a valid hostname or IP address.") );
	return false;
    }

    // checking print server
    if ( printserver != "" &&
	Hostname::Check(printserver) != true && Hostname::CheckFQ(printserver) != true &&
	IP::Check4(printserver) != true
    ) {
	UI::SetFocus ( `id ( "printserver" ) );
	// error popup
	Popup::Error ( _("The specified value is not a valid hostname or IP address.") );
	return false;
    }

    // checking wins server
    if ( winsserver != "" &&
	Hostname::Check(winsserver) != true && Hostname::CheckFQ(winsserver) != true &&
	IP::Check4(winsserver) != true
    ) {
	UI::SetFocus ( `id ( "winsserver" ) );
	// error popup
	Popup::Error ( _("The specified value is not a valid hostname or IP address.") );
	return false;
    }

    return true;
}

/**
 * Common Config Dialog - Dynamic DHCP
 * @return term for Get_CommonDialog()
 */
term Common_DynamicDHCPDialog() {
    term dialog = 
	`VBox(
            `VBox(
		// frame
                `Frame (_("IP Address Range") ,
		    `VBox(

		    `HBox (
			`HWeight (2,
			    // TRANSLATORS: informative text entry (filled up, disabled)
			    `TextEntry( `id("current_network"), _("Current &Network") )
			),
			`HWeight (2,
			    // TRANSLATORS: informative text entry (filled up, disabled)
			    `TextEntry( `id("current_netmask"), _("Current Net&mask") )
			),
			`HWeight (1,
			    // TRANSLATORS: informative text entry (filled up, disabled)
			    `TextEntry( `id("current_bits"),    _("Netmask Bi&ts"))
			)
		    ),

		    `VSpacing(1),

		    `HBox (
			`VBox (
			    // text entry
			    `Left( `TextEntry ( `id ("from_ip"), _("&First IP Address") ) ),
			    // text entry
			    `Left( `TextEntry ( `id ("to_ip"), _("&Last IP Address") ) )
			),
			`VBox (
			    // text entry
			    `Left( `TextEntry ( `id ("from_ip_min"), _("Min&imum IP Address") ) ),
			    // text entry
			    `Left( `TextEntry ( `id ("to_ip_max"), _("Ma&ximum IP Address") ) )
			)
		    )

		    )
		) 
            ),
	    `VSpacing (1),
            `Frame(
		// frame label
		_("Lease Time"),
                `HBox(
		    `opt(`hstretch),
		    `HWeight(
			// Textentry label - lease time for IPs in the range
                	3, `TextEntry(`id("defaultleasetime"), _("&Default"))
		    ),
		    `HWeight(
			2, `MinWidth(
			    TimeComboLabelLength(),
                    	    // Combobox - type of units for lease time
			    `ComboBox(`id("defaultleasetimeunits"), _("&Units"),
				time_combo_items
                    	    )
			)
		    ),
		    `HSpacing(1),
		    `HWeight(
			// TextEntryLabel - max. time for leasing of IPs from the range
			3, `TextEntry(`id("maxleasetime"), _("&Maximum"))
		    ),
		    `HWeight(
			2, `MinWidth(
			    TimeComboLabelLength(),
			    // Combobox - type of units for max lease time
                    	    `HSquash (`ComboBox(`id("maxleasetimeunits"), _("Uni&ts"),
				time_combo_items
                    	    ))
			)
		    )
                )
            ),
	    `VStretch(),
	    `ReplacePoint (`id (`dns_advanced), `Empty())
        );

    return dialog;
}

void DynamicDHCPValidChars ()
{
    // ValidChars definition for DynamicDHCPDialog
    UI::ChangeWidget(`id( "from_ip" ),		`ValidChars, IP::ValidChars4);
    UI::ChangeWidget(`id( "to_ip" ),		`ValidChars, IP::ValidChars4);
    UI::ChangeWidget(`id( "defaultleasetime" ),	`ValidChars, "0123456789");
    UI::ChangeWidget(`id( "maxleasetime" ),	`ValidChars, "0123456789");
}

map <string, string> current_dynamic_dhcp = $[];

void DynamicDHCPInit (string key)
{
    // find out the our subnet identification
    
    list<string> ifaces_allowed = DhcpServer::GetAllowedInterfaces ();
    
    if ( size(ifaces_allowed) > 1 )
    {
	y2warning ("More than one interface allowed, using the first one only.");
    }
    
    if ( size(ifaces_allowed) == 0 )
    {
	y2error ("No interfaces set");
	return;
    }

    string interface = ifaces_allowed[0]:nil;
    map m = DhcpServer::GetInterfaceInformation (interface);
    string id = m["network"]:"" + " netmask " + m["netmask"]:"";
    string zone_name = CurrentDomainName();

    current_dynamic_dhcp = $[
	"network" : m["network"]:"",
	"netmask" : m["netmask"]:"",
	"domain"  : zone_name,
    ];

    integer netmask_bits = Netmask::ToBits(m["netmask"]:"255.255.255.255");
    current_dynamic_dhcp["netmask_bits"] = tostring(netmask_bits);

    UI::ChangeWidget( `id("current_network"), `Value, m["network"]:"");
    UI::ChangeWidget( `id("current_network"), `Enabled, false);
    UI::ChangeWidget( `id("current_netmask"), `Value, m["netmask"]:"");
    UI::ChangeWidget( `id("current_netmask"), `Enabled, false);
    UI::ChangeWidget( `id("current_bits"),    `Value, tostring (netmask_bits));
    UI::ChangeWidget( `id("current_bits"),    `Enabled, false);

    // Computing minimal and maximal IPs
    string current_network = IP::ComputeNetwork (m["network"]:"", m["netmask"]:"255.255.255.255");
    string network_binary  = IP::IPv4ToBits (current_network);

    current_dynamic_dhcp["current_network"] = current_network;
    current_dynamic_dhcp["network_binary"]  = network_binary;

    // generating reverse zone
    if (IP::Check(current_network)) {
	// 10.20.60.2  / 255.255.255.0 -> 60.20.10.in-addr.arpa
	// 135.14.80.2 / 255.255.240.0 -> 14.135.in-addr.arpa
	// 10.20.60.2  / 255.128.0.0   -> 10.in-addr.arpa

	string reverse_zone = "";

	// only 255's are valid for a reverse zone
	integer network_bytes = netmask_bits / 8;
	list <string> network_split = splitstring (current_network, ".");
	while (network_bytes > 0) {
	    network_bytes = network_bytes - 1;
	    reverse_zone = reverse_zone + network_split[network_bytes]:"" + ".";
	}
	reverse_zone = reverse_zone + "in-addr.arpa";
	
	current_dynamic_dhcp["reverse_domain"] = reverse_zone;
    }

    // Computing minimal IP
    string ipv4_min = regexpsub (network_binary, "^(.*).$", "\\11");
    ipv4_min = IP::BitsToIPv4 (ipv4_min);

    // Computing maximal IP
    string ipv4_max = substring (network_binary, 0, netmask_bits);
    ipv4_max = ipv4_max + "11111111111111111111111111111111";
    ipv4_max = substring (ipv4_max, 0, 32);
    // changing the last bit not to be >1< (reserved for broadcast)
    ipv4_max = regexpsub (ipv4_max, "(.*)1$", "\\10");
    ipv4_max = IP::BitsToIPv4 (ipv4_max);

    y2milestone("Network: %1, Min. IP: %2, Max. IP: %3", m["network"]:"", ipv4_min, ipv4_max);

    UI::ChangeWidget( `id("from_ip_min"), `Enabled, false);
    UI::ChangeWidget( `id("to_ip_max"),   `Enabled, false);
    if (ipv4_min != nil && ipv4_max != nil) {
	UI::ChangeWidget( `id("from_ip_min"), `Value, ipv4_min);
	UI::ChangeWidget( `id("to_ip_max"), `Value,   ipv4_max);
	
	current_dynamic_dhcp["ipv4_min"] = ipv4_min;
	current_dynamic_dhcp["ipv4_max"] = ipv4_max;
    }
    

    y2milestone ("Id to lookup: %1", id );

    if (! DhcpServer::EntryExists ("subnet", id) )
    {
	DhcpServer::CreateEntry ("subnet", id, "", "" );
    }

    // FIXME: it may not exist
    list < map< string,string> > directives
	= DhcpServer::GetEntryDirectives ( "subnet", id );

    integer default_lease_time = 14400;
    integer max_lease_time = 172800;

    if (directives != nil)
    {
	foreach (map<string,string> opt, directives, ``{
	    if ( opt["key"]:nil == "range" )
	    {
		list<string> range = splitstring ( opt["value"]:"", " " );
		UI::ChangeWidget ( `id ("from_ip"), `Value, range[0]:"" );
		UI::ChangeWidget ( `id ("to_ip"), `Value, range[1]:"" );
	    }
	    else if ( opt["key"]:nil == "default-lease-time" )
	    {
		default_lease_time = tointeger ( opt["value"]:"0" );
	    }
	    else if ( opt["key"]:nil == "max-lease-time" )
	    {
		max_lease_time = tointeger ( opt["value"]:"0" );
	    }
	});
    }
    map vu = seconds2time (default_lease_time);
    integer value = vu["count"]:0;
    string unit = vu["unit"]:"seconds";
    UI::ChangeWidget ( `id ("defaultleasetime"), `Value, tostring (value) );
    UI::ChangeWidget ( `id ("defaultleasetimeunits"), `Value, unit );

    vu = seconds2time (max_lease_time);
    value = vu["count"]:0;
    unit = vu["unit"]:"seconds";
    UI::ChangeWidget ( `id ("maxleasetime"), `Value, tostring (value) );
    UI::ChangeWidget ( `id ("maxleasetimeunits"), `Value, unit );

    DynamicDHCPValidChars ();
    
    // Synchronize DNS Server -- init
    map <string, map <string, string> > all_zones = DnsServerAPI::GetZones();
    list <term> possible_dns_actions = [];

    // zone is not maintained by the DNS server
    if (all_zones[zone_name]:nil == nil) {
	possible_dns_actions = [
	    `item(`id(`dns_advanced_from_scratch), _("Create New DNS Zone from Scratch"))
	];

    // zone is maintained and it is a 'master'
    } else if (all_zones[zone_name,"type"]:nil == "master") {
	possible_dns_actions = [
	    `item(`id(`dns_advanced_from_scratch), _("Create New DNS Zone from Scratch")),
	    `item(`id(`dns_advanced_edit_current), _("Edit Current DNS Zone"))
	];

    // zone is maintained but it is not a 'master'
    } else {
	possible_dns_actions = [
	    `item(`id(`dns_advanced_zone_info), _("Get Current Zone Information"))
	];
    }

    UI::ReplaceWidget (`id(`dns_advanced), `MenuButton (
	`id(`dns_advanced_menu),
	_("&Synchronize DNS Server..."),
	possible_dns_actions
    ));

    UI::ChangeWidget (`id (`dns_advanced_menu), `Enabled, DhcpServer::IsDnsServerAvailable());
}

boolean DynamicDHCPValidate (string key, map event);

symbol DynamicDHCPHandle (string key, map event) {
    if (key != "dynamic_dhcp") return nil;

    // Only these IDs are handled
    if (
	event["ID"]:nil != `dns_advanced_edit_current
	&&
	event["ID"]:nil != `dns_advanced_from_scratch
	&&
	event["ID"]:nil != `dns_advanced_zone_info
    ) return nil;

    // Show DNS Zone Information
    if (event["ID"]:nil == `dns_advanced_zone_info) {
	Report::Message (sformat (
	    _("DNS zone %1 is not a master zone.
This means that you cannot change it here.
"),
	    current_settings["domain"]:""
	));

    // Run the DNS Wizard - Zone from Scratch
    } else if (event["ID"]:nil == `dns_advanced_from_scratch) {
	if (! DynamicDHCPValidate(nil, nil)) {
	    y2milestone("Dynamic DHCP Validation failed, Not managing DNS Server");
	    return nil;
	}

	y2milestone("Running DNS wizard -- Creating zone from scratch");
	RunNewDNSServerWizard (current_dynamic_dhcp);

    // Edit the current DNS Zone - for experts
    } else if (event["ID"]:nil == `dns_advanced_edit_current) {
	if (! DynamicDHCPValidate(nil, nil)) {
	    y2milestone("Dynamic DHCP Validation failed, Not managing DNS Server");
	    return nil;
	}

	y2milestone("Managing DNS Server");
	ManageDNSServer (current_dynamic_dhcp);
    }
    
    return nil;
}

void DynamicDHCPStore (string key, map event)
{
    list<string> ifaces_allowed = DhcpServer::GetAllowedInterfaces ();

    // we assume there is only a single interface at this stage        
    string interface = ifaces_allowed[0]:nil;

    map m = DhcpServer::GetInterfaceInformation (interface);
    string id = m["network"]:"" + " netmask " + m["netmask"]:"";

    y2milestone ("Id to store: %1", id );

    list < map< string,string> > directives 
	= DhcpServer::GetEntryDirectives ( "subnet", id );
	
    if ( directives == nil ) 
    {
	directives = [];
    }

    string from_ip = (string) UI::QueryWidget ( `id ("from_ip"), `Value );
    string to_ip = (string) UI::QueryWidget ( `id ("to_ip"), `Value );
    
    // FIXME: validation
    
    // now update the directives
    
    // remove the old ones
    list<string> keys = [ "max-lease-time", "range", "default-lease-time" ];
    
    directives = filter ( map<string,string> opt, directives, ``( 
	! contains (keys, opt["key"]:"")
    ));
    
    if ( size(from_ip) != 0 && size(to_ip) != 0 )
    {
	directives = add ( directives, 
	    $[ "key" : "range" , "value" : from_ip + " " + to_ip ]
	);
    }

    string value = (string)UI::QueryWidget ( `id ("defaultleasetime"), `Value );
    if (size(value)>0)
    {
	integer val = tointeger (value);
	string units = (string)
	    UI::QueryWidget ( `id ("defaultleasetimeunits"), `Value );
	val = time2seconds (val, units);
	directives = add (directives, $[ "key" : "default-lease-time", "value": tostring (val) ] );
    }

    value = (string)UI::QueryWidget ( `id ("maxleasetime"), `Value );
    if (size(value)>0)
    {
	integer val = tointeger (value);
	string units = (string)
	    UI::QueryWidget ( `id ("maxleasetimeunits"), `Value );
	val = time2seconds (val, units);
	directives = add (directives, $[ "key" : "max-lease-time", "value": tostring (val) ] );
    }

    DhcpServer::SetEntryDirectives ( "subnet", id, directives );    
}

boolean DynamicDHCPValidate (string key, map event)
{
    string from_ip		= (string) UI::QueryWidget ( `id ("from_ip"),		`Value );
    string to_ip		= (string) UI::QueryWidget ( `id ("to_ip"),		`Value );
    string defaultleasetime	= (string) UI::QueryWidget ( `id ("defaultleasetime"),	`Value );
    string maxleasetime		= (string) UI::QueryWidget ( `id ("maxleasetime"),	`Value );

    if (from_ip == "" && to_ip == "") {
	// disable dynamic IP assigning
	return true;
    }

    // defined only one, both from and to must be defined
    if ( from_ip != "" && to_ip == "" ) {
	UI::SetFocus ( `id ( "to_ip" ) );
	// A popup error text
	Popup::Error ( _("Enter values for both ends of the IP address range.") );
	return false;
    }

    // defined only one, both from and to must be defined
    if ( from_ip == "" && to_ip != "" ) {
	UI::SetFocus ( `id ( "from_ip" ) );
	// A popup error text
	Popup::Error ( _("Enter values for both ends of the IP address range.") );
	return false;
    }

    // Checking from_ip for IPv4
    if ( from_ip != "" && IP::Check4(from_ip) == false ) {
	UI::SetFocus ( `id ( "from_ip" ) );
	Popup::Error ( IP::Valid4 () );
	return false;
    }

    // Checking to_ip for IPv4
    if ( to_ip != "" && IP::Check4(to_ip) == false ) {
	UI::SetFocus ( `id ( "to_ip" ) );
	Popup::Error ( IP::Valid4 () );
	return false;
    }

    // FIXME: Lease Time should NOT be zero or means zero NO expiration?

    // network of the current network interface
    string current_network = IP::ComputeNetwork (current_dynamic_dhcp["network"]:"", current_dynamic_dhcp["netmask"]:"");

    // checking from_ip network with the current network
    string from_ip_network = IP::ComputeNetwork(from_ip, current_dynamic_dhcp["netmask"]:"");
    if (from_ip_network != "" && current_network != nil && current_network != "" && current_network != from_ip_network) {
	UI::SetFocus(`id ( "from_ip" ));
	Report::Error(
	    // TRANSLATORS: popup error message
	    //              %1 is the tested IP which should match network %2 and netmask %3
	    sformat(_("The dynamic DHCP address range must be in the same network as the DHCP server.
IP %1 does not match the network %2/%3."),
	    from_ip, current_dynamic_dhcp["network"]:"", current_dynamic_dhcp["netmask"]:"")
	);
	return false;
    }

    // checking to_ip network with the current network
    string to_ip_network   = IP::ComputeNetwork(to_ip, current_dynamic_dhcp["netmask"]:"");
    if (to_ip_network != "" && current_network != nil && current_network != "" && current_network != to_ip_network) {
	UI::SetFocus(`id ( "to_ip" ));
	Report::Error(
	    // TRANSLATORS: popup error message
	    //              %1 is the tested IP which should match network %2 and netmask %3
	    sformat(_("The dynamic DHCP address range must be in the same network as the DHCP server.
IP %1 does not match the network %2/%3."),
	    to_ip, current_dynamic_dhcp["network"]:"", current_dynamic_dhcp["netmask"]:"")
	);
	return false;
    }

    
    current_dynamic_dhcp["from_ip"] = from_ip;
    current_dynamic_dhcp["to_ip"]   = to_ip;

    return true;
}

/**
 * Common Config Dialog - Host Management
 * @return term for Get_CommonDialog()
 */

term Common_HostManagementDialog() {
    term dialog = `VBox(
    	    `VBox (
		    // Label of the registered hosts table
                    `Left(`Label(_("Registered Host"))),
                    `Table(`id("registered_hosts_table"), 
			`opt(`notify, `immediate, `vstretch),
			`header(
			// Table header item - Name of the host
			_("Name"), 
			// Table header item - IP of the host
			_("IP"), 
			// MAC address of the host
			_("Hardware Address"), 
			// Network type of the host
			_("Type")))
            ),

	    // Frame label - configuration of particular host
            `VSquash (`Frame( _("List Setup"),
                `VBox (
                    `Top (`HBox (
			`Top (
			    `VBox (
                        	`HBox (
				    // Textentry label - name of the host
                            	    `Left (`TextEntry(`id("hostname"), _("&Name"))),
				    // noneditable textentry
                            	    `Left (`TextEntry(`id("domain"), `opt(`disabled), "  "))
                        	),
				// Textentry label - IP address of the host
                        	`Left (`TextEntry(`id("hostip"), _("&IP Address")))
                    	    )
			),

			`HSpacing(2),

                        `Top(
			    `VBox(
				// Textentry label - hardware (mac) address of the host
                        	`Left (`TextEntry(`id("hosthwaddress"), _("&Hardware Address"))),
				// Radiobutton label - network type of the host
                        	`RadioButtonGroup (`id("network_type"), 
                            	    `HBox(
                                	`Left (`RadioButton(`id("ethernet"), _("&Ethernet"), true)),
                                	`Left (`RadioButton(`id("token-ring"), _("&Token Ring")))
                            	    )
                        	)
                    	    )
			)
                    )),
                    `VSpacing(1),
		    `Top (`Left (`HBox (
			// Pushbutton label - add host into list
                        `Left (`PushButton(`id("addhost"), Label::AddButton ())),
                        `HSpacing(1),
			// Pushbutton label - change host in list
                        `Left (`PushButton(`id("edithost"), _("C&hange in List"))),
                        `HSpacing(1),
			// Pushbutton label - delete host from list
                        `Left (`PushButton(`id("deletehost"), _("Dele&te from List")))
            	    )))
                )
            ))
        );

    return dialog;
}

void HostManagementValidChars ()
{
    // ValidChars definition for HostManagementDialog
    UI::ChangeWidget(`id( "hostname" ),		`ValidChars, Hostname::ValidChars);
    UI::ChangeWidget(`id( "hostip" ),		`ValidChars, IP::ValidChars4);
    UI::ChangeWidget(`id( "hosthwaddress" ),	`ValidChars, "ABCDEFabcdef0123456789:");
}

string hosts_parent_id = "";

map<string, map<string, string> > hosts = $[];

void SelectItem (string id)
{
    map<string,string> opts = hosts[id]:$[];
    
    UI::ChangeWidget ( `id ("hostname"), `Value, id ); 
    UI::ChangeWidget ( `id ("hostip"), `Value, opts["ip"]:"" ); 
    UI::ChangeWidget ( `id ("hosthwaddress"), `Value, opts["hardware"]:"" ); 
    UI::ChangeWidget ( `id ("network_type"), `CurrentButton, opts["type"]:"ethernet" ); 
}

void HostManagementInit (string key)
{
    hosts = $[];
    hosts_parent_id = "";

    list<string> ifaces_allowed = DhcpServer::GetAllowedInterfaces ();

    // we assume there is only a single interface at this stage
    string interface = ifaces_allowed[0]:nil;

    map m = DhcpServer::GetInterfaceInformation (interface);
    string id = m["network"]:"" + " netmask " + m["netmask"]:"";

    hosts_parent_id = id;

    y2milestone ("Id to get hosts from: %1", id );
    
    if (! DhcpServer::EntryExists ("subnet", id) )
    {
	DhcpServer::CreateEntry ("subnet", id, "", "" );
    }

    // now, get the list of interesting children
    list< map<string,string> > children = DhcpServer::GetChildrenOfEntry ("subnet", id);

    foreach (map<string,string> child, children, ``{
	if (child["type"]:nil == "host")
	{
	    string child_id = child["id"]:"";
	    // let's initialize our cache
	    hosts[ child_id ] = $[];
	    
	    list< map<string,string> > directives = DhcpServer::GetEntryDirectives ("host", child["id"]:"");
	    foreach ( map<string,string> opt, directives, ``{
		if( opt["key"]:nil == "hardware" )
		{
		    list<string> parts = splitstring (opt["value"]:"", " ");
		    
		    hosts[ child_id, "hardware" ] = parts[1]:"";
		    hosts[ child_id, "type" ] = parts[0]:"ethernet";
		}
		else if (opt["key"]:nil == "fixed-address")
		{
		    hosts[ child_id, "ip" ] = opt["value"]:"";
		}
	    });
	}
    });
    
    // now, fill the dialog
    list<term> items = maplist (string id, map<string,string> opts, hosts, ``(
	`item ( `id (id), id, opts["ip"]:""
	    , opts["hardware"]:""
	    , opts["type"]:"ethernet" == "ethernet" ? _("Ethernet") : _("Token Ring") )
    ));
    
    UI::ChangeWidget ( `id("registered_hosts_table"), `Items, items );
    
    if ( size(items) > 0 )
    {
	// fill the corresponding fields
	SelectItem ( items[0,1]:"" );
    }

    // get the global options
    list< map<string,string> > options = DhcpServer::GetEntryOptions ("","");
    
    if ( options == nil )
    {
	options = [];
    }

    // setup the corresponding values
    foreach ( map<string,string> opt, options, ``{
	if ( opt["key"]:nil == "domain-name" ) {
	    string value = opt["value"]:"";
	    value = regexpsub (value, "^[ \t]*\"(.*)\"[ \t]*$", "\\1");
	    if (size(value) > 0) {
		value = "." + value;
	    }
	    UI::ChangeWidget ( `id("domain"), `Value, value );
	    break;
	}
    });
    HostManagementValidChars ();
}

list< map<string,string> > PrepareDirectives ()
{
    list <map<string,string> > directives = [];
	
    string value = (string) UI::QueryWidget ( `id ("hostip"), `Value );
    if (size(value) > 0)
    {
	// FIXME: validation
	directives = add (directives, $[ "key" : "fixed-address" ,
		"value" : value ] );
    }
	
    value = (string) UI::QueryWidget ( `id ("hosthwaddress" ), `Value );
    if (size(value) > 0)
    {
	// FIXME: validation
	string type = (string) UI::QueryWidget ( `id ("network_type"), `CurrentButton );
	directives = add (directives, $[ "key" : "hardware" ,
		"value" : type +" " + value ] );
    }
	
    return directives;
}

boolean CheckMacAddrFormat () {
    string hosthwaddress = (string)
	UI::QueryWidget ( `id ("hosthwaddress"), `Value );
    string addr_type
	= (string) UI::QueryWidget ( `id ("network_type"), `CurrentButton );
    if (addr_type == "ethernet" || addr_type == "token-ring")
    {
	 if( !Address::CheckMAC(hosthwaddress))
      {
	  UI::SetFocus (`id ("hosthwaddress"));
	  Report::Error (
	    // error popup
	      _("The hardware address is invalid.\n") + Address::ValidMAC());
	  return false;
      }
    }
    return true;
}

boolean CheckMacAddrUnique (string original) {
    list<map<string,string> > existing
	= DhcpServer::GetChildrenOfEntry ("subnet", hosts_parent_id );
    list<string> addresses = maplist (map<string,string> h, existing, {
	if (h["id"]:"" != original)
	{
	    list<map<string,string> > directives
		= DhcpServer::GetEntryDirectives (h["type"]:"", h["id"]:"");
	    string addr = nil;
	    find (map<string,string> d, directives, {
		if (d["key"]:"" == "hardware")
		{
		    addr = d["value"]:"";
		    return true;
		}
		return false;
	    });
	    return addr;
	}
	else
	{
	    return nil;
	}
    });
    addresses = filter (string a, addresses, {return a != nil;});
    boolean address_unique = true;
    find (map<string,string> d, PrepareDirectives (), {
	if (d["key"]:"" == "hardware")
	{
	    if (contains (addresses, d["value"]:""))
		address_unique = false;
	    return true;
	}
	return false;
    });

    if (! address_unique)
    {
	UI::SetFocus (`id ("hosthwaddress"));
	// error popup
	Popup::Error (_("The hardware address must be unique."));
	return false;
    }
    return true;
}

boolean CheckHostId (string name) {
    if (size (name) == 0 )
    {
	    UI::SetFocus (`id("hostname"));
	    // error popup
	    Popup::Error (_("The hostname cannot be empty."));
	    return false;
    }
    else if (! Hostname::Check(name))
    {
	    UI::SetFocus (`id("hostname"));
	    Popup::Error (Hostname::ValidFQ());
	    return false;
    }
    else if ( haskey (hosts, name) )
    {
	    UI::SetFocus (`id("hostname"));
	    // error popup, %1 is host name
	    Popup::Error (sformat (_("A host named %1 already exists."), name));
	    return false;
    }
    return true;
}

symbol HostManagementHandle (string key, map event_descr)
{
    if ( event_descr["ID"]:"" == "addhost" )
    {
	string name = (string) UI::QueryWidget ( `id ("hostname"), `Value );
	if (! CheckHostId (name))
	    return nil;

	// checking new IP
	string hostip = (string) UI::QueryWidget ( `id ("hostip"), `Value );
	if ( size ( hostip ) == 0 )
	{
	    UI::SetFocus ( `id ( "hostip" ) );
	    // error popup
	    Popup::Error ( _("Enter a host IP.") );
	    return nil;
	}
	else if ( IP::Check4 ( hostip ) != true )
	{
	    UI::SetFocus ( `id ( "hostip" ) );
	    Popup::Error ( IP::Valid4 () );
	    return nil;
	}

	// checking new MAC
	string hosthwaddress = (string) UI::QueryWidget ( `id ("hosthwaddress"), `Value );
	if ( size ( hosthwaddress ) == 0 )
	{
	    UI::SetFocus ( `id ( "hosthwaddress" ) );
	    // error popup
	    Report::Error ( _("The hardware address must be defined.") );
	    return nil;
	}
	// check the syntax
	if (! CheckMacAddrFormat ())
	    return nil;

	// check if MAC address is unique
	if (! CheckMacAddrUnique (nil))
	    return nil;

	// finally create the entry
	DhcpServer::CreateEntry ( "host", name, "subnet", hosts_parent_id );
	DhcpServer::SetEntryDirectives ( "host", name, PrepareDirectives () );

	HostManagementInit (key);
    }
    else if ( event_descr["ID"]:"" == "deletehost" )
    {
	string id = (string) UI::QueryWidget ( `id ("registered_hosts_table")
	    , `CurrentItem );
	    
	if (id == nil)
	{
	    // error popup
	    Popup::Error (_("Select a host first.") );
	    return nil;
	}
	// yes-no popup
	if ( ! Confirm::Delete (id))
	{
	    return nil;
	}
	
	DhcpServer::DeleteEntry ( "host", id );

	HostManagementInit (key);
    }
    else if ( event_descr["ID"]:"" == "edithost" )
    {
	string id = (string) UI::QueryWidget ( `id ("registered_hosts_table")
	    , `CurrentItem );
	    
	if (id == nil)
	{
	    Popup::Error (_("Select a host first.") );
	    return nil;
	}

	// check the new ID
	string new_id = (string)UI::QueryWidget (`id ("hostname"), `Value);
	if (new_id != id && ! CheckHostId (new_id))
	{
	    return nil;
	}

	// checking new IP
	string hostip = (string) UI::QueryWidget ( `id ("hostip"), `Value );
	if ( size ( hostip ) == 0 )
	{
	    // FIXME: text?
	    UI::SetFocus ( `id ( "hostip" ) );
	    Popup::Error ( _("Enter a host IP.") );
	    return nil;
	}
	else if ( IP::Check4 ( hostip ) != true )
	{
	    UI::SetFocus ( `id ( "hostip" ) );
	    Popup::Error ( IP::Valid4 () );
	    return nil;
	}

	// checking new MAC
	string hosthwaddress = (string) UI::QueryWidget ( `id ("hosthwaddress"), `Value );
	if ( size ( hosthwaddress ) == 0 )
	{
	    UI::SetFocus ( `id ( "hosthwaddress" ) );
	    Popup::Error ( _("The input value must be defined.") );
	    return nil;
	}

	// check the syntax
	if (! CheckMacAddrFormat ())
	    return nil;

	// check if MAC address is unique
	if (! CheckMacAddrUnique (id))
	    return nil;

	if (id != new_id)
	{
	    DhcpServer::DeleteEntry ("host", id);
	    id = new_id;
	    DhcpServer::CreateEntry ("host", id, "subnet", hosts_parent_id);
	}
	DhcpServer::SetEntryDirectives ("host", id, PrepareDirectives ());

	HostManagementInit (key);
    }
    else if ( event_descr["ID"]:"" == "registered_hosts_table" 
	&& event_descr["EventReason"]:"" == "SelectionChanged" )
    {
	string id = (string) UI::QueryWidget ( `id ("registered_hosts_table")
	    , `CurrentItem );
	    
	if ( id != nil )
	{
	    SelectItem (id);
	}
    }
    return nil;
}

void HostManagementStore (string key, map event)
{
    return;
}

symbol ExpertSettingsTabInit (string tab) {
    y2warning ("Tab: %1", tab);
    if (tab == "expert_settings")
    {
	// yes-no popup
	if (! Popup::YesNo (_("If you enter the expert settings, you cannot return 
to this dialog. You may be able to display this dialog 
by saving the changes and restarting the module. 
If too complex a configuration is set, the expert 
settings dialog is displayed when you
start the DHCP server module.

Continue?")))
	{
	    return `refuse_display;
	}
	else
	{
	    return `expert;
	}
    }
    return nil;
}

void OtherOptionsInit (string key) {
    string params = DhcpServer::GetOtherOptions();
    UI::ChangeWidget(`id("other_opts"), `Value, params);
}

map <string, boolean> valid_opts = $[
    "p" : true,
    "f" : false,
    "d" : false,
    "q" : false,
    "t" : false,
    "T" : false,
    "cf": true,
    "lf": true,
    "tf": true,
    "play": true,
];

boolean OtherOptionsValidate(string key, map event) {
    string cmdline = (string) UI::QueryWidget(`id("other_opts"), `Value);
    //remove leading '-'
    if (size(cmdline) > 0) cmdline = substring(cmdline,1);
    boolean correct = true;

    map <string, string> options = listmap(string s, splitstring(cmdline,"-"), {
	list <string> wrk = splitstring(s," ");
	return $[wrk[0]:"" : wrk[1]:""];
    });

    y2milestone("Cmdline options: %1", options);

    foreach(string k, string v, options, {
	if (!haskey(valid_opts,k)) {
	    UI::SetFocus(`id("other_opts"));
	    Popup::Error( sformat(_("\"\-%1\" is not a valid DHCP server commandline option"),k));
	    correct = false;
	    break;
	} else {
	    if(v == "" && valid_opts[k]:false){
	        UI::SetFocus(`id("other_opts"));
	        Popup::Error( sformat(_("DHCP server commandline option \"\-%1\" requires an argument"),k));
		correct = false;
		break;
	    }
	    if(k == "cf") {
		UI::SetFocus(`id("other_opts"));
		correct = (Popup::ContinueCancel(sformat(_("You have specified an alternate configuration file for DHCP server.\n
This is not supported by YaST, as DHCP server module can only read and write
/etc/dhcpd.conf. New configuration from %1 will not be imported and all changes 
will be saved to the default configuration file.
 
Really continue?"), v))); 
		break;
	    }
	}
    });
//    y2milestone("Commandline options parsed");
    return correct;
}

void OtherOptionsStore(string key, map event) {
    string params = (string) UI::QueryWidget(`id("other_opts"), `Value);

    DhcpServer::SetOtherOptions(params);
}

map<string, map<string, any> > tabs = $[
    "start_up" : $[
	"contents"	: `VBox (
	    "auto_start_up",
//	    `VSpacing(),
	    "use_ldap",
	    `VSpacing(),
	    "start_stop",
	    `VSpacing(),
	    "other_options",
	    `VStretch ()
	),
	// dialog caption
	"caption"	: _("DHCP Server: Start-Up"),
	// dialog caption
	"wizard"	: _("Start-Up"),
	// tree item
	"tree_item_label"	: _("Start-Up"),
	"widget_names"	: ["auto_start_up", "use_ldap", "start_stop", "expert_settings", "other_options"],
    ],
    "card_selection" : $[
	"contents"	: `VBox (
	    `VSpacing (1),
	    Common_CardSelectionDialog(),
	    `VSpacing (1),
	    `Left ("open_firewall"),
	    `VStretch ()
	),
	// dialog caption
	"caption"	: _("DHCP Server: Card Selection"),
	// dialog caption
	"wizard"	: _("Card Selection"),
	// tree item
	"tree_item_label"	: _("Card Selection"),
	"widget_names"	: ["card_selection", "open_firewall",
	    "expert_settings", ],
    ],
    "global_settings" : $[
	"contents"	: Common_GlobalSettingsDialog(),
	// dialog caption
	"caption"	: _("DHCP Server: Global Settings"),
	// dialog caption
	"wizard"	: _("Global Settings"),
	// tree item
	"tree_item_label"	: _("Global Settings"),
	"widget_names"	: ["global_settings", "expert_settings"],
    ],
    "dynamic_dhcp" : $[
	"contents"	: Common_DynamicDHCPDialog(),
	// dialog caption
	"caption"	: _("DHCP Server: Dynamic DHCP"),
	// dialog caption
	"wizard"	: _("Dynamic DHCP"),
	// tree item
	"tree_item_label"	: _("Dynamic DHCP"),
	"widget_names"	: ["dynamic_dhcp", "expert_settings"],
    ],
    "host_management" : $[
	"contents"	: Common_HostManagementDialog(),
	// dialog caption
	"caption"	: _("DHCP Server: Host Management"),
	// tree item
	"tree_item_label"	: _("Host Management"),
	"widget_names"	: ["host_management", "expert_settings"],
    ],
    "expert_settings" : $[
	// dialog caption
	"caption"	: _("DHCP Server: Expert Settings"),
	// tree item
	"tree_item_label"	: _("Expert Settings"),
	"init"		: ExpertSettingsTabInit,
    ],
    "inst_summary" : $[
	"contents" : `VBox (
	    `VSpacing (1),
	    "auto_start_up",
	    `VSpacing (1),
	    "config_summary",
	    `VSpacing (1),
	    "all_settings_button",
	    `VSpacing (1)
	),
	// dialog caption
	"wizard" : _("Start-Up"),
	"widget_names" : ["auto_start_up", "config_summary", "all_settings_button"],
    ],
];

boolean GetStartService () {
    return DhcpServer::GetStartService ();
}

void SetStartService (boolean start) {
    DhcpServer::SetStartService (start);
}

void SaveAndRestart () {
    Wizard::CreateDialog ();
    Wizard::RestoreHelp (HELPS["write"]:"");
    DhcpServer::Write ();
    UI::CloseDialog ();
}

map<string,map<string,any> > new_widgets = (map<string,map<string,any> >)union (
  widgets,
  $[
    "auto_start_up" : CWMServiceStart::CreateAutoStartWidget ($[
	"get_service_auto_start" : GetStartService,
	"set_service_auto_start" : SetStartService,
	// radio button
	"start_auto_button" : _("When &Booting"),
	// radio button
	"start_manual_button" : _("&Manually"),
	"help" : sformat (CWMServiceStart::AutoStartHelpTemplate (),
	    // part of help text - radio button label, NO SHORTCUT!!!
	    _("When Booting"),
	    // part of help text - radio button label, NO SHORTCUT!!!
	    _("Manually")),
    ]),
    "start_stop" : CWMServiceStart::CreateStartStopWidget ($[
	"service_id" : "dhcpd",
	// label - service status
	"service_running_label" : _("DHCP server is running"),
	// label - service status
	"service_not_running_label" : _("DHCP server is not running"),
	// push button
	"start_now_button" : _("&Start DHCP Server Now"),
	// push button
	"stop_now_button" : _("S&top DHCP Server Now"),
	"save_now_action" : SaveAndRestart,
	// push button
	"save_now_button" : _("Save Settings and Restart DHCP Server &Now"),
	"help" : sformat (CWMServiceStart::StartStopHelpTemplate (true),
	    // part of help text - push button label, NO SHORTCUT!!!
	    _("Start DHCP Server Now"),
	    // part of help text - push button label, NO SHORTCUT!!!
	    _("Stop DHCP Server Now"),
	    // part of help text - push button label, NO SHORTCUT!!!
	    _("Save Settings and Restart DHCP Server Now")),
    ]),
    "use_ldap" : CWMServiceStart::CreateLdapWidget ($[
	"get_use_ldap" : DhcpServer::GetUseLdap,
	"set_use_ldap" : SetUseLdap,
    ]),
    "card_selection" : $[
	"widget"	: `custom,
	"custom_widget"	: `VBox (),
	"init"		: CardSelectionInit,
	"handle"	: CardSelectionHandle,
	"store"		: CardSelectionStore,
	"validate_type"	: `function,
	"validate_function"	: CardSelectionValidate,
	"help"		:  HELPS["card_selection_expert"]:"",
    ],
    "global_settings" : $[
	"widget"	: `custom,
	"custom_widget"	: `VBox (),
	"init"		: GlobalSettingsInit,
	"handle"	: GlobalSettingsHandle,
	"validate_type"	: `function,
	"validate_function" : GlobalSettingsValidate,
	"store"		: GlobalSettingsStore,
	"help"		: HELPS["ldap_support"]:"" + HELPS["ldap_server_name"]:"" + HELPS["global_settings"]:""
    ],
    "dynamic_dhcp" : $[
	"widget"	: `custom,
	"custom_widget"	: `VBox (),
	"init"		: DynamicDHCPInit,
	"validate_type"	: `function,
	"validate_function"	: DynamicDHCPValidate,
	"handle"	: DynamicDHCPHandle,
	"store"		: DynamicDHCPStore,
	"help"		: HELPS["dynamic_dhcp"]:"",
    ],
    "host_management" : $[
	"widget"	: `custom,
	"custom_widget"	: `VBox (),
	"init"		: HostManagementInit,
	"handle"	: HostManagementHandle,
	"store"		: HostManagementStore,
	"help"		: HELPS["host_management"]:"",
    ],
    "expert_settings" : $[
	"widget"	: `custom,
	"custom_widget"	: `VBox (),
	"help"		: HELPS["expert_settings"]:" ",
    ],
    "config_summary" : $[
	"widget"	: `custom,
	"custom_widget"	: `Empty (),
	"help"		: HELPS["config_summary"]:" ",
    ],
    "other_options" : $[
	"widget"	: `custom,
	"custom_widget" : `TextEntry (`id("other_opts"), "DHCP Server Start-Up Arguments"),
	"init"		: OtherOptionsInit,
	"validate_type"	: `function,
	"validate_function" : OtherOptionsValidate,
	"store"		: OtherOptionsStore,
	"help"		: HELPS["other_options"]:" ",
    ],
]);

/**
 * Common Config Dialog
 * @return symbol for the wizard sequencer
 */
symbol CommonConfigDialog () {
    list <string> ids_order = ["start_up", "card_selection", "global_settings",
	    "dynamic_dhcp", "host_management", "expert_settings"];
    return DialogTree::ShowAndRun ($[
	"ids_order" : ids_order,
	"initial_screen" : "start_up",
	"screens" :  tabs,
	"widget_descr" : widgets,
	"back_button" : "",
	"abort_button" :  Label::CancelButton (),
	"next_button" : Label::FinishButton (),
	"functions" : functions,
    ]);
}



symbol FirstRunDialog (string current_tab, integer step_number) {
    map<string,any> tab_descr = tabs[current_tab]:$[];

    // dialog caption, %1 is step number
    string caption = sformat (_("DHCP Server Wizard (%1 of 4)"), step_number)
	+ ": " + tab_descr["wizard"]:"";

    symbol ret = CWM::ShowAndRun ($[
	"widget_names" : tab_descr["widget_names"]:[],
	"widget_descr" : widgets,
	"contents" : tab_descr["contents"]:`VBox (),
	"caption" :  caption,
	"back_button" : Label::BackButton (),
	"next_button" : step_number == 4
	    ? Label::FinishButton ()
	    : Label::NextButton (),
	"fallback_functions" : $[`abort : confirmAbortIfChanged],
    ]);

    return ret;
}

/* EOF */
}



