/**
 * File:	include/dhcp-server/dns-server-dialogs.ycp
 * Package:	Configuration of dhcp-server
 * Summary:	Synchronization with DNS Server (shared dialogs)
 * Authors:	Lukas Ocilka <lukas.ocilka@suse.cz>
 *
 * $Id:$
 */

{

    textdomain "dhcp-server";
    
    import "IP";
    import "Label";
    import "Report";
    import "Punycode";
    import "Hostname";
    import "DnsServerAPI";

    boolean IsDNSZoneMaintained (string zone_name) {
	if (zone_name == nil) {
	    y2error("Undefined zone name");
	    return nil;
	}

	map <string, map <string, string> > all_zones = DnsServerAPI::GetZones();

	// found or not?
	return (all_zones[zone_name]:nil == nil);
    }

    boolean IsDNSZoneMaster (string zone_name) {
	if (zone_name == nil) {
	    y2error("Undefined zone name");
	    return nil;
	}
	
	map <string, map <string, string> > all_zones = DnsServerAPI::GetZones();
	
	// if zone not found
	boolean ret = nil;
	
	// is master or not?
	if (all_zones[zone_name]:nil != nil) {
	    ret = (all_zones[zone_name, "type"]:nil == "master");
	}

	return ret;
    }

    void CreateUI_DNSRangeDialog (string range_min, string range_max, map <string, any> old_range) {
	// old_range: $[
	//     "base"  : "dhcp-%",
	//     "start" : 0,
	//     "from"  : "192.168.10.1",
	//     "to"    : "192.168.10.100"
	// ]

	// TRANSLATORS: dialog caption
	string dialog_caption = _("Add New DNS Record Range");
	if (old_range != $[] && old_range != nil) {
	    // TRANSLATORS: dialog caption
	    dialog_caption = _("Edit DNS Record Range");
	}

	UI::OpenDialog (`VBox (
	    `MarginBox (1, 1, `Frame (
		dialog_caption,
		`VBox (
		    `HBox (
			// TRANSLATORS: text entry
			`TextEntry (`id ("current_range_min"), _("Min&imum IP Address")),
			// TRANSLATORS: text entry
			`TextEntry (`id ("current_range_max"), _("Ma&ximum IP Address"))
		    ),
		    `HBox (
			// TRANSLATORS: text entry
			`TextEntry (`id ("hostname_base"), _("&Hostname Base")),
			// TRANSLATORS: text entry
			`TextEntry (`id ("hostname_start"), _("&Start"))
		    ),
		    `HBox (
			// TRANSLATORS: text entry
			`TextEntry (`id ("first_ip"), _("&First IP Address")),
			// TRANSLATORS: text entry
			`TextEntry (`id ("last_ip"),  _("&Last IP Address"))
		    )
		)
	    )),
	    `HBox (
		`PushButton (`id(`ok), Label::OKButton()),
		`HSpacing (1),
		`PushButton (`id(`cancel), Label::CancelButton())
	    )
	));
	
	UI::ChangeWidget (`id("current_range_min"), `Value, range_min);
	UI::ChangeWidget (`id("current_range_max"), `Value, range_max);
	
	// FIXME: default
	UI::ChangeWidget (`id("hostname_base"),  `Value, old_range["base"]:"dhcp-%i");
	UI::ChangeWidget (`id("hostname_start"), `Value, tostring (old_range["start"]:1));
	
	UI::ChangeWidget (`id("current_range_min"), `Enabled, false);
	UI::ChangeWidget (`id("current_range_max"), `Enabled, false);

	UI::ChangeWidget (`id ("first_ip"),       `ValidChars, IP::ValidChars4);
	UI::ChangeWidget (`id ("last_ip"),        `ValidChars, IP::ValidChars4);
	UI::ChangeWidget (`id ("hostname_start"), `ValidChars, "0123456789");
	
	// Predefining possible values
	UI::ChangeWidget (`id ("first_ip"), `Value, old_range["from"]:range_min);
	UI::ChangeWidget (`id ("last_ip"),  `Value, old_range["to"]:range_max);
    }

    boolean CheckDNSRange (string first_ip, string last_ip, map <string, string> & current_d_settings) {
	// range in binary form
	string first_ip_bin = IP::IPv4ToBits(first_ip);
	string last_ip_bin  = IP::IPv4ToBits(last_ip);
	
	// they have to be defined
	if (first_ip_bin == nil || last_ip_bin == nil) {
	    Report::Error (sformat(
		// TRANSLATORS: popup error, %1 is the first IP of the range, %2 is the last one
		_("Internal error.\nCannot create IP range from %1 and %2."),
		first_ip, last_ip
	    ));
	    return false;
	}
	
	// network mask in binary form
	integer bits = tointeger(current_d_settings["netmask_bits"]:nil);
	string  network_bits = current_d_settings["network_binary"]:nil;
	// first x bits from network in binary form
	network_bits = substring(network_bits, 0, bits);
	y2milestone("Network Mask: %1", network_bits);
	
	// doest the first IP match the current network?
	string first_ip_mask = substring(first_ip_bin, 0, bits);
	// network bits must be the same in both IP and Network
	if (first_ip_mask != network_bits) {
	    Report::Error (
		// TRANSLATORS: popup error, %1 is an IP address
		// %2 is a network, %3 is a netmask
		sformat (_("IP address %1 does not match
the current network %2/%3.
"),
		first_ip, current_d_settings["network"]:"", current_d_settings["netmask"]:""
	    ));
	    UI::SetFocus(`id("first_ip"));
	    return false;
	}
	
	// does the second IP match the current network?
	string last_ip_mask  = substring(last_ip_bin, 0, bits);
	// network bits must be the same in both IP and Network
	if (last_ip_mask != network_bits) {
	    Report::Error (
		sformat (_("IP address %1 does not match
the current network %2/%3
"),
		last_ip, current_d_settings["network"]:"", current_d_settings["netmask"]:""
	    ));
	    UI::SetFocus(`id("last_ip"));
	    return false;
	}
	
	// the Address part of IPs
	first_ip_bin = substring (first_ip_bin, bits);
	last_ip_bin  = substring (last_ip_bin, bits);
	y2milestone("First IP: %1", first_ip_bin);
	y2milestone("Last IP:  %1", last_ip_bin);
	
	// the Address part of the DHCP range
	string fist_ip_dhcp = IP::IPv4ToBits (current_d_settings["from_ip"]:"");
	string last_ip_dhcp = IP::IPv4ToBits (current_d_settings["to_ip"]:"");
	fist_ip_dhcp = substring(fist_ip_dhcp, bits);
	last_ip_dhcp = substring(last_ip_dhcp, bits);
	
	// isn't the first IP bigger than the last one?
	if (tointeger (first_ip_bin) > tointeger (last_ip_bin)) {
	    // TRANSLATORS: popup error
	    Report::Error (_("The last IP address must be higher than the first one."));
	    return false;
	}
	
	// isn't the first IP out of the current DHCP range?
	if (tointeger (first_ip_bin) < tointeger (fist_ip_dhcp) || tointeger (fist_ip_dhcp) > tointeger (last_ip_dhcp)) {
	    Report::Error (sformat (
		// TRANSLATORS: popup error, %1 an IP address
		// %2 is the first IP address of the range, %3 is the last one
		_("The IP address %1 is out of the current
dynamic DHCP range %2-%3.
"),
		first_ip, current_d_settings["from_ip"]:"", current_d_settings["to_ip"]:""
	    ));
	    return false;
	}

	// isn't the last IP out of the current DHCP range?
	if (tointeger (last_ip_bin) < tointeger (fist_ip_dhcp) || tointeger (last_ip_dhcp) > tointeger (last_ip_dhcp)) {
	    Report::Error (sformat (
		// TRANSLATORS: popup error, %1 an IP address
		// %2 is the first IP address of the range, %3 is the last one
		_("The IP address %1 is
out of the current
dynamic DHCP range %2-%3.
"),
		last_ip, current_d_settings["from_ip"]:"", current_d_settings["to_ip"]:""
	    ));
	    return false;
	}
	
	return true;
    }

    boolean IPisInRangeOfIPs (string ipv4, string first_ip, string last_ip) {
	// Checking delta between first_ip and last_ip
	list <integer> ipv4_list = maplist (string ip_part, splitstring(ipv4, "."), {
	    return tointeger(ip_part);
	});
	list <integer> first_ip_list = maplist (string ip_part, splitstring(first_ip, "."), {
	    return tointeger(ip_part);
	});
	list <integer> last_ip_list = maplist (string ip_part, splitstring(last_ip, "."), {
	    return tointeger(ip_part);
	});
	
	// Computing deltas
	// 195(.168.0.1) - 192(.11.0.58) => 3
	integer address_1_1 = (ipv4_list[0]:0 - first_ip_list[0]:0);
	integer address_1_2 = (ipv4_list[1]:0 - first_ip_list[1]:0);
	integer address_1_3 = (ipv4_list[2]:0 - first_ip_list[2]:0);
	integer address_1_4 = (ipv4_list[3]:0 - first_ip_list[3]:0);

	integer address_2_1 = (last_ip_list[0]:0 - ipv4_list[0]:0);
	integer address_2_2 = (last_ip_list[1]:0 - ipv4_list[1]:0);
	integer address_2_3 = (last_ip_list[2]:0 - ipv4_list[2]:0);
	integer address_2_4 = (last_ip_list[3]:0 - ipv4_list[3]:0);
		
	boolean range_status = nil;

	// Firstly, checking the IPv4 and the first address in the range
	// IPv4 must be bigger or equal to it
	if (ipv4 == first_ip) {
	    range_status = true;

	// first chunk is either smaller or bigger than zero
	} else if (address_1_1 < 0 || address_1_1 > 0) {
	    // bigger means that the IP range is correct
	    range_status = (address_1_1 > 0);

	// if they are equal, check the very next chunk...
	} else if (address_1_2 < 0 || address_1_2 > 0) {
	    range_status = (address_1_2 > 0);

	} else if (address_1_3 < 0 || address_1_3 > 0) {
	    range_status = (address_1_3 > 0);

	} else if (address_1_4 < 0 || address_1_4 > 0) {
	    range_status = (address_1_4 > 0);

	// what else?
	} else {
	    y2error("Unknown match IP: %1 First: %2", ipv4_list, first_ip_list);
	    range_status = false;
	}
	
	// First checking didn't match
	if (! range_status) return false;

	// Secondly, checking the IPv4 and the last address in the range
	// IPv4 must be smaller or equal to it
	if (ipv4 == last_ip) {
	    range_status = true;

	// first chunk is either smaller or bigger than zero
	} else if (address_2_1 < 0 || address_2_1 > 0) {
	    // bigger means that the IP range is correct
	    range_status = (address_2_1 > 0);

	// if they are equal, check the very next chunk...
	} else if (address_2_2 < 0 || address_2_2 > 0) {
	    range_status = (address_2_2 > 0);

	} else if (address_2_3 < 0 || address_2_3 > 0) {
	    range_status = (address_2_3 > 0);

	} else if (address_2_4 < 0 || address_2_4 > 0) {
	    range_status = (address_2_4 > 0);

	// what else?
	} else {
	    y2error("Unknown match IP: %1 Last: %2", ipv4_list, last_ip_list);
	    range_status = false;
	}
	
	return range_status;
    }

    map <string, any> ValidateAddDNSRangeDialog (map <string, string> & current_d_settings) {
	map <string, any> ret = nil;

	string hostname_base = (string) UI::QueryWidget (`id("hostname_base"), `Value);
	y2milestone("Entered hostname base: %1", hostname_base);

	// checking number of '%i' in the hostname base
	string nr_hostname_base = hostname_base;
	integer i_count = 0;
	while (regexpmatch (nr_hostname_base, "%i")) {
	    i_count = i_count + 1;
	    nr_hostname_base = regexpsub (nr_hostname_base, "(.*)%i(.*)", "\\1--\\2");
	}
	if (i_count > 1) {
	    Report::Error (
		// TRANSLATORS: popup error '%i' is a special string, do not translate it, please
		_("There can be only one '%i' in the hostname base string.")
	    );
	    return nil;
	}
	nr_hostname_base = nil;
	
	string hostname_base_check = hostname_base;
	if (hostname_base_check != "" && hostname_base_check != nil) {
	    // integer listed
	    if (regexpmatch(hostname_base_check, "%i")) {
		hostname_base_check = regexpsub(hostname_base_check, "^(.*)%i(.*)", "\\10\\2");
	    // add something
	    } else {
		hostname_base_check = hostname_base_check + "0";
	    }
		    
	    hostname_base_check = Punycode::EncodeDomainName(hostname_base_check);
	}

	y2milestone("Checking hostname base: %1", hostname_base_check);
		
	// Checking the hostname base
	if (hostname_base_check == "" || hostname_base_check == nil || ! Hostname::Check(hostname_base_check)) {
	    UI::SetFocus(`id ("hostname_base"));
	    // TRANSLATORS: popup error, followed by a newline and a valid hostname description
	    Report::Error(_("Invalid hostname.") + "\n\n" + Hostname::ValidHost());
	    return nil;
	}

	string first_ip = (string) UI::QueryWidget (`id("first_ip"), `Value);
	if (! IP::Check4(first_ip)) {
	    UI::SetFocus(`id("first_ip"));
	    // TRANSLATORS: popup error, followed by a newline and a valid IPv4 description
	    Report::Error(_("Invalid IP address.") + "\n\n" + IP::Valid4());
	    return nil;
	}

	if (! IPisInRangeOfIPs (
	    first_ip,
	    (string) current_d_settings["ipv4_min"]:"",
	    (string) current_d_settings["ipv4_max"]:""
	)) {
	    Report::Error (sformat (
		// TRANSLATORS: popup error, %1 is an IP address
		// %2 is the first IP address of the range, %3 is the last one
		_("IP address %1 is not in the range of allowed
IP addresses (%2-%3) defined in the DHCP server.
"),
		first_ip, current_d_settings["ipv4_min"]:"",
		current_d_settings["ipv4_max"]:""
	    ));
	    return nil;
	}
	
	string last_ip = (string) UI::QueryWidget (`id("last_ip"), `Value);
	if (! IP::Check4(last_ip)) {
	    UI::SetFocus(`id("last_ip"));
	    // TRANSLATORS: popup error, followed by a newline and a valid IPv4 description
	    Report::Error(_("Invalid IP address.") + "\n\n" + IP::Valid4());
	    return nil;
	}

	if (! IPisInRangeOfIPs (
	    last_ip,
	    (string) current_d_settings["ipv4_min"]:"",
	    (string) current_d_settings["ipv4_max"]:""
	)) {
	    Report::Error (sformat (
		// TRANSLATORS: popup error, %1 is an IP address
		// %2 is the first IP address of the range, %3 is the last one
		_("IP address %1 is not in the range of allowed
IP addresses (%2-%3) defined in the DHCP server.
"),
		first_ip, current_d_settings["ipv4_min"]:"",
		current_d_settings["ipv4_max"]:""
	    ));
	    return nil;
	}

	string hostname_start_s = (string) UI::QueryWidget (`id("hostname_start"), `Value);
	integer hostname_start = 0;
	if (regexpmatch(hostname_start_s, "^[0123456789]+$")) {
	    hostname_start = tointeger(hostname_start_s);
	}
		
	if (! CheckDNSRange (first_ip, last_ip, current_d_settings)) return nil;
	
	ret = $[
	    "hostname_base"  : hostname_base,
	    "hostname_start" : hostname_start,
	    "first_ip"       : first_ip,
	    "last_ip"        : last_ip,
	];
	
	return ret;
    }

    boolean AddDNSRangeWorker (
	string domain,
	string hostname_domain,
	string record_type,
	string hostname_base,
	integer hostname_start,
	string first_ip,
	string last_ip
    ) {
	if (! contains(["A", "PTR"], record_type)) {
	    y2error("Record type %1 is not handled by this function", record_type);
	    return false;
	}

	if (regexpmatch(hostname_base, "%i")) {
	    hostname_base = regexpsub(hostname_base, "^(.*)%i(.*)", "\\1%1\\2");
	} else {
	    hostname_base = hostname_base + "%1";
	}
	y2milestone("Hostname base: %1", hostname_base);

	if (hostname_start == nil) hostname_start = 0;

	list <integer> first_ip_list = maplist (string ip_part, splitstring(first_ip, "."), {
	    return tointeger(ip_part);
	});
	list <integer> last_ip_list = maplist (string ip_part, splitstring(last_ip, "."), {
	    return tointeger(ip_part);
	});
	y2milestone("Creating range: %1 - %2", first_ip, last_ip);

	// list of hostnames for next punycode translation
	list <string> hostnames = [];
	// list of IPs matching these hostnames (by index)
	list <string> ips       = [];

	integer hostname_counter = hostname_start - 1;
	integer index_counter    = -1;
	
	// for counting max numbers
	integer to_2 = nil;
	integer to_3 = nil;
	integer to_4 = nil;

	// Generating hostnames and IPs
	while (first_ip_list[0]:1 <= last_ip_list[0]:0) {

	    // Range (1).1.1.1 -> (2).1.1.1
	    //           contains (1).254.254.254
	    if (first_ip_list[0]:1 < last_ip_list[0]:0) {
	        to_2 = 254;
	    } else {
	        to_2 = last_ip_list[1]:0;
	    }
	    while (first_ip_list[1]:1 <= to_2) {

		// Range 1.(1).1.1 -> 1.(2).1.1
		//           contains 1.(1).254.254
		if (first_ip_list[1]:1 < last_ip_list[1]:0) {
		    to_3 = 254;
		} else {
		    to_3 = last_ip_list[2]:0;
		}
		while (first_ip_list[2]:1 <= to_3) {

		    // Range 1.1.(1).1 -> 1.1.(2).1
		    //           contains 1.1.(1).254
		    if (first_ip_list[2]:1 < last_ip_list[2]:0) {
			to_4 = 254;
		    } else {
			to_4 = last_ip_list[3]:0;
		    }
		    while (first_ip_list[3]:1 <= to_4) {
			// 0 at the end of IP address means network
			// skip it!
			if (first_ip_list[3]:nil == 0) {
			    y2milestone("Skipping %1", first_ip_list);
			    first_ip_list[3] = first_ip_list[3]:0 + 1;
			    continue;
			}
		    
			hostname_counter = hostname_counter + 1;
			index_counter    = index_counter    + 1;
			
			hostnames[index_counter] = sformat (hostname_base, hostname_counter);
			
			if (record_type == "A") {
			    ips[index_counter] =   sformat (
							"%1.%2.%3.%4",
							first_ip_list[0]:0,
							first_ip_list[1]:0,
							first_ip_list[2]:0,
							first_ip_list[3]:0
						    );
			} else if (record_type == "PTR") {
			    ips[index_counter] =   sformat (
							"%1.%2.%3.%4.in-addr.arpa.",
							first_ip_list[3]:0,
							first_ip_list[2]:0,
							first_ip_list[1]:0,
							first_ip_list[0]:0
						    );
			}
			first_ip_list[3] = first_ip_list[3]:0 + 1;
		    }
		    first_ip_list[2] = first_ip_list[2]:0 + 1;
		    first_ip_list[3] = 0;
		}
		first_ip_list[1] = first_ip_list[1]:0 + 1;
		first_ip_list[2] = 0;
	    }
	    first_ip_list[1] = 0;
	    first_ip_list[0] = first_ip_list[0]:0 + 1;
	}

	// Writing records into the DNS Server
	if (hostname_counter > 0) {
	    hostnames = Punycode::EncodePunycodes (hostnames);

	    index_counter = -1;	    
	    foreach (string one_hostname, hostnames, {
		index_counter = index_counter + 1;
		
		if (record_type == "A") {
		    DnsServerAPI::AddZoneRR (
			domain, "A", one_hostname, ips[index_counter]:""
		    );
		} else if (record_type == "PTR") {
		    DnsServerAPI::AddZoneRR (
			domain,
			"PTR",
			ips[index_counter]:"",
			one_hostname + "." + hostname_domain + "."
		    );
		}
	    });
	}

	return true;
    }

// EOF
}
